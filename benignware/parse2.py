from pyparsing import Word, hexnums, WordEnd, Optional, alphas, alphanums
import numpy as np
import cv2
import os
import struct

np.set_printoptions(threshold=np.inf)
fake_opcodes = ['include', 'align', 'public', 'dd', 'dw', 'assume', 'proc', 'endp', 'db', 'extrn']
path = ""
files = os.listdir(path+"asm\\")

hex_integer = Word(hexnums) + WordEnd() # use WordEnd to avoid parsing leading a-f of non-hex numbers as a hex
line = Word(alphas,alphanums)("opcode")
state_label =  [('mov', 'mov'), ('push', 'push'), ('push', 'mov'), ('push', 'call'), ('mov', 'push'), ('mov', 'call'), ('call', 'mov'), ('pop', 'pop'), ('test', 'jz'), ('mov', 'test'), ('jz', 'mov'), ('mov', 'cmp'), ('call', 'add'), ('mov', 'pop'), ('pop', 'retn'), ('mov', 'lea'), ('add', 'mov'), ('lea', 'mov'), ('cmp', 'jnz'), ('cmp', 'jz'), ('lea', 'push'), ('jmp', 'mov'), ('mov', 'add'), ('mov', 'jmp'), ('push', 'lea'), ('jnz', 'mov'), ('retn', 'push'), ('test', 'jnz'), ('call', 'push'), ('mov', 'xor'), ('pop', 'mov'), ('mov', 'sub'), ('lea', 'call'), ('jz', 'push'), ('xor', 'mov'), ('call', 'test'), ('sub', 'mov'), ('retn', 'mov'), ('jz', 'cmp'), ('call', 'pop'), ('add', 'test'), ('jmp', 'push'), ('jnz', 'push'), ('mov', 'and'), ('call', 'lea'), ('add', 'cmp'), ('add', 'push'), ('call', 'jmp'), ('mov', 'movzx'), ('mov', 'inc'), ('cmp', 'jb'), ('cmp', 'mov'), ('jmp', 'lea'), ('jnz', 'cmp'), ('add', 'jmp'), ('jmp', 'cmp'), ('add', 'add'), ('lea', 'jmp'), ('xor', 'pop'), ('add', 'pop'), ('movzx', 'mov'), ('sub', 'push'), ('call', 'cmp'), ('inc', 'mov'), ('cmp', 'ja'), ('cmp', 'jl'), ('and', 'mov'), ('mov', 'shr'), ('mov', 'jz'), ('jz', 'lea'), ('add', 'retn'), ('cmp', 'jnb'), ('xor', 'push'), ('xor', 'call'), ('jmp', 'xor'), ('text', 'text'), ('cmp', 'jbe'), ('or', 'mov'), ('movsd', 'movsd'), ('test', 'mov'), ('xor', 'jmp'), ('push', 'sub'), ('lea', 'cmp'), ('cmp', 'jle'), ('jb', 'mov'), ('jz', 'test'), ('cmp', 'jge'), ('mov', 'retn'), ('xor', 'cmp'), ('mov', 'or'), ('add', 'lea'), ('mov', 'jnz'), ('mov', 'shl'), ('jle', 'mov'), ('inc', 'cmp'), ('pop', 'xor'), ('xor', 'test'), ('lea', 'lea'), ('jnz', 'xor'), ('pop', 'test'), ('sub', 'cmp'), ('mov', 'imul'), ('jnz', 'lea'), ('push', 'jmp'), ('test', 'js'), ('test', 'jle'), ('jnz', 'test'), ('call', 'xor'), ('cmp', 'jg'), ('and', 'cmp'), ('jnb', 'mov'), ('pop', 'add'), ('jl', 'mov'), ('lea', 'add'), ('dec', 'mov'), ('movups', 'movups'), ('jg', 'mov'), ('call', 'retn'), ('movups', 'mov'), ('jbe', 'mov'), ('add', 'xor'), ('jz', 'xor'), ('push', 'pop'), ('imul', 'mov'), ('push', 'xor'), ('jz', 'add'), ('nop', 'mov'), ('retn', 'cmp'), ('jz', 'sub'), ('movzx', 'push'), ('movzx', 'movzx'), ('mov', 'sar'), ('xor', 'xor'), ('test', 'jns'), ('pop', 'jmp'), ('sub', 'jz'), ('jmp', 'call'), ('jnz', 'call'), ('shr', 'mov'), ('jge', 'mov'), ('jmp', 'test'), ('jnz', 'pop'), ('ja', 'mov'), ('shl', 'or'), ('jnz', 'jmp'), ('jnz', 'add'), ('and', 'push'), ('add', 'sub'), ('movzx', 'cmp'), ('jmp', 'jmp'), ('shl', 'add'), ('mov', 'movups'), ('sar', 'mov'), ('sub', 'jnz'), ('jz', 'call'), ('mov', 'dec'), ('movzx', 'shl'), ('shl', 'mov'), ('xor', 'add'), ('pop', 'push'), ('imul', 'add'), ('jz', 'inc'), ('js', 'mov'), ('retn', 'sub'), ('movzx', 'add'), ('add', 'call'), ('sub', 'add'), ('test', 'jg'), ('push', 'add'), ('inc', 'add'), ('fstp', 'fld'), ('sub', 'lea'), ('pop', 'call'), ('call', 'call'), ('call', 'sub'), ('add', 'movzx'), ('jz', 'movzx'), ('mov', 'movsd'), ('and', 'add'), ('retn', 'xor'), ('and', 'lea'), ('retn', 'lea'), ('and', 'or'), ('shr', 'and'), ('lea', 'test'), ('inc', 'push'), ('mov', 'cdq'), ('inc', 'test'), ('sub', 'sar'), ('xor', 'inc'), ('mov', 'nop'), ('and', 'and'), ('xor', 'lea'), ('and', 'sub'), ('jmp', 'dec'), ('retn', 'call'), ('movss', 'movss'), ('lea', 'xor'), ('jmp', 'add'), ('lea', 'sub'), ('cmp', 'setz'), ('movsd', 'mov'), ('leave', 'retn'), ('movzx', 'jmp'), ('movq', 'movq'), ('jb', 'cmp'), ('shr', 'add'), ('sub', 'jmp'), ('movzx', 'test'), ('mov', 'movsx'), ('call', 'movzx'), ('jz', 'and'), ('cmp', 'lea'), ('or', 'jmp'), ('sub', 'sub'), ('jmp', 'movzx'), ('dec', 'test'), ('neg', 'sbb'), ('push', 'cmp'), ('jnz', 'sub'), ('inc', 'jmp'), ('jnz', 'movzx'), ('add', 'inc'), ('jle', 'push')]
opcode_label =  ['mov', 'push', 'call', 'lea', 'pop', 'cmp', 'jmp', 'add', 'jz', 'test', 'xor', 'jnz', 'retn', 'sub', 'and', 'inc', 'movzx', 'or', 'text', 'jb', 'dec', 'fld', 'shl', 'fstp', 'jl', 'shr', 'leave', 'xchg', 'jle', 'jnb', 'jbe', 'imul', 'ja', 'sar', 'movsd', 'jge', 'jg', 'neg', 'movsx', 'fmul', 'sbb', 'rep', 'not', 'adc', 'cdq', 'stosd', 'stc', 'clc', 'cmc', 'js', 'setnz', 'rol', 'vmovss', 'movlpd', 'jns', 'ror', 'nop', 'mul', 'setz', 'lock', 'fadd', 'fnstsw', 'xorps', 'cmovnb', 'bswap', 'fild', 'idiv', 'faddp', 'fsub', 'movq', 'movups', 'fldz', 'cmovnz', 'int', 'addsd', 'div', 'fdiv', 'mulsd', 'fcomp', 'movd', 'cmovz', 'fxch', 'fmulp', 'jp', 'fld1', 'pushf', 'fst', 'setnle', 'movaps', 'repne', 'movapd', 'wait', 'bts', 'subsd', 'rcr', 'fcom', 'bt', 'btr', 'fchs', 'vaddss', 'jnp', 'mulpd', 'rcl', 'shld', 'shrd', 'movdqa', 'sal', 'btc', 'cmovb', 'vmulss', 'vxorps', 'vsubss', 'movss', 'vmovdqu', 'cmovle', 'vcomiss', 'pfmul', 'pxor', 'fsubp', 'lodsd', 'lahf', 'fucompp', 'cvtdq2pd', 'cwde', 'sets', 'fldcw', 'bsr', 'cmova', 'psrlq', 'vmovq', 'andpd', 'pextrw', 'fnstcw', 'cld', 'addpd', 'fstsw', 'pshufd', 'retf', 'setl', 'repe', 'xorpd', 'bsf', 'cvtpd2ps', 'setnl', 'stosw', 'comisd', 'sahf', 'setb', 'fsubr', 'vmovaps', 'xadd', 'pfadd', 'cmovg', 'psllq', 'mulss', 'fdivp', 'divsd', 'fdivr', 'cbw', 'pand', 'fistp', 'movdqu', 'punpckhdq', 'seto', 'stosb', 'cmovs', 'punpckldq', 'paddd', 'fcompp', 'cmovns', 'ldmxcsr', 'mulps', 'cmovl', 'divss', 'end', 'orpd', 'cwd', 'popf', 'popa', 'fabs', 'addss', 'subss', 'pmaddwd', 'cmovbe', 'fucom', 'movsw', 'std', 'cmovge', 'in', 'fstcw', 'pinsrw', 'vcvtsi2ss', 'pusha', 'lfence', 'stmxcsr', 'setnbe', 'cvtsi2sd', 'vpxor', 'shufps', 'fsqrt', 'addps', 'comiss', 'fucomp', 'fdivrp', 'unpcklpd', 'vcvttss2si', 'pmovmskb', 'ucomisd', 'vzeroupper', 'setle', 'out', 'paddw', 'cvttsd2si', 'fsubrp', 'vmovsd', 'subpd', 'setns', 'vdivss', 'cvtps2pd', 'vucomiss', 'por', 'cpuid', 'frndint', 'xmmword']

cnt = 1
for file in files:
    print(str(cnt)+"/"+str(len(files)))
    cnt += 1
    markov = [['header']]
    markov[0].extend(state_label)
    for i in range(len(state_label)):
        tmp = [state_label[i]]
        for j in range(len(state_label)):
            tmp.append(0)
        markov.append(tmp)
    with open(path+"asm\\"+file, encoding='utf8') as f1:
        source = f1.readlines()
    opcode_sequence = []
    for source_line in source:
        if len(source_line)>17 and source_line[16] >= 'a' and source_line[16] <= 'z' and source_line[0:16]=='                ':
            result = line.parseString(source_line)
            if "opcode" in result and result.opcode not in fake_opcodes:
                if result.opcode in opcode_label:
                    opcode_sequence.append(result.opcode)
    instr_cnt = 0
    last_state = None
    while True:
        if instr_cnt>len(opcode_sequence)-2:
            break
        if last_state in state_label and (opcode_sequence[instr_cnt], opcode_sequence[instr_cnt+1]) in state_label:
            markov[state_label.index(last_state)+1][state_label.index((opcode_sequence[instr_cnt], opcode_sequence[instr_cnt+1]))+1] += 1
        last_state = (opcode_sequence[instr_cnt], opcode_sequence[instr_cnt+1])
        instr_cnt += 2
        
    instr_cnt = 1
    last_state = None
    while True:
        if instr_cnt>len(opcode_sequence)-2:
            break
        if last_state in state_label and (opcode_sequence[instr_cnt], opcode_sequence[instr_cnt+1]) in state_label:
            markov[state_label.index(last_state)+1][state_label.index((opcode_sequence[instr_cnt], opcode_sequence[instr_cnt+1]))+1] += 1
        last_state = (opcode_sequence[instr_cnt], opcode_sequence[instr_cnt+1])
        instr_cnt += 2
    img = markov[1:]
    for i in range(len(img)):
        img[i] = img[i][1:]

    cvtImg = np.array(img, dtype=np.float32)
    cvtImg = cvtImg*255 / cvtImg.max()
    I=np.zeros([len(cvtImg), len(cvtImg), 3],dtype=np.uint8)
    for i in range(len(cvtImg)):
        for j in range(len(cvtImg[0])):
            temp = hex(struct.unpack('<I', struct.pack('<f', cvtImg[i][j]))[0])
            if temp != '0x0':
                r = temp[2:4]
                g = temp[4:6]
                b = temp[6:8]
                I[i][j][0] = int(r, base=16)
                I[i][j][1] = int(g, base=16)
                I[i][j][2] = int(b, base=16)
    # cv2.imshow('img', I)
    # cv2.waitKey(0)
    list_file = list(file)
    list_file[-1] = 'g'
    list_file[-2] = 'p'
    list_file[-3] = 'j'
    list_file[-4] = '.'
    imgFile = ''.join(list_file)
    cv2.imwrite(path+"img2\\"+imgFile, I)
